---
title: The Store
---

The `Store` is a single object which contains the store state and serves as the _single source of truth_.

To create a store, you need to extend Akita's `Store`, passing the type as well as its initial state:

```ts title="session.store.ts"
import { Store, StoreConfig } from '@datorama/akita';

export interface SessionState {
   token: string;
   name: string;
}

export function createInitialState(): SessionState {
  return {
    token: '',
    name: ''
  };
}

@StoreConfig({ name: 'session' })
export class SessionStore extends Store<SessionState> {
  constructor() {
    super(createInitialState());
  }
}
```

With this setup you get a `Store` with the following methods:

### `update()`

When you want to update the store, you can call the `update()` method passing the new `state`:

```ts title="session.service.ts"
import { SessionStore } from './session.store';

export class SessionService {
  constructor(private sessionStore: SessionStore) {}

  updateUserName(newName: string) {
    this.sessionStore.update({ name: newName });
  }
}
```

The second `update()` option gives you more control. It receives a `callback` function, which gets the current state, and returns a new **immutable** state, which will be the new value of the store. For example:

```ts title="session.service.ts"
import { SessionStore } from './session.store';

export class SessionService {
  constructor(private sessionStore: SessionStore) {}

  updateUserName(newName: string) {
    this.sessionStore.update(state => ({
      name: newName
    }));
  }
}
```

### `set()`

When you don't just want to update the current store state but replace the state completely, you can call the `set()` method passing the new `state`:

```ts title="session.service.ts"
import { SessionStore } from './session.store';

export class SessionService {
  constructor(private sessionStore: SessionStore) {}

  updateUserName(newName: string) {
    this.sessionStore.set({ name: newName });
  }
}
```

As with `update()` the `set()` method also has a second option which gives you more control. It receives a `callback` function, which gets the current state, and returns a new **immutable** state, which will be the new value of the store. For example:

```ts title="session.service.ts"
import { SessionStore } from './session.store';

export class SessionService {
  constructor(private sessionStore: SessionStore) {}

  updateUserName(newName: string) {
    this.sessionStore.set(state => ({
      name: newName
    }));
  }
}
```

You should use `set()` over `update()` when you want to completely replace the current state at the top level.

```ts title="session.store.ts"
type SessionState = SessionStateAuthenticated | SessionStateUnauthenticated;

interface SessionStateAuthenticated {
  _tag: 'session-state-authenticated';
  user: User;
}

interface SessionStateUnauthenticated {
  _tag: 'session-state-unauthenticated'
}

interface User {
  uid: string;
  displayName: string;
}

```

```json "current state"
{
  "_tag": "session-state-authenticated",
  "user": {
    "uid": "123",
    "displayName": "John Doe"
  }
}
```

Using the above state model and value of current state, if we call `this.store.update({ _tag: 'session-state-unauthenticated' })` our state will be updated to the following:

```json "using the update() method"
{
  "_tag": "session-state-unauthenticated",
  "user": {
    "uid": "123",
    "displayName": "John Doe"
  }
}
```

Our value for tag has been updated but the user value from our previous state has stayed, this could lead to unintended side effects so in this case `this.store.set({ _tag: 'session-state-unauthenticated' })` may be a better option. When we use the `set()` method the following is the result:

```json "using the update() method"
{
  "_tag": "session-state-unauthenticated",
}
```

We have replaced the previous state completely, leaving behind no unexpected state values.


### `setLoading()`

Set the `loading` state:
```ts title="session.service.ts"
import { SessionStore } from './session.store';

export class SessionService {
  constructor(private sessionStore: SessionStore,
              private http: HttpClient) {}

  async updateUserName(newName: string) {
    this.sessionStore.setLoading(true);
    await this.http(...).toPromise();
    this.sessionStore.update({ name: newName});
    this.sessionStore.setLoading(false);
  }
}
```

### `setError()`
Set the `error` state:

```ts title="session.service.ts"
import { SessionStore } from './session.store';

export class SessionService {
  constructor(private sessionStore: SessionStore,
              private http: HttpClient) {}

  async updateUserName(newName: string) {
    try {
      await this.http(...).toPromise();
    } catch(error) {
      this.sessionStore.setError(error);
    }
  }
}
```

### `destroy()`
Destroys the store:
```ts
sessionStore.destroy();
```


